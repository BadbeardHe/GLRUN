'''
Author: Jin Zeng (slightly modified by He Changyong)
Date: 2023-04-13
LastEditTime: 2023-08-08
Description: evaluate depth error, output RMSE, MAE, iRMSE, iMAE, delta
'''
import os
import argparse

import numpy as np
import cv2


# try:
#     from skimage.metrics import structural_similarity as compare_ssim
# except Exception:
#     from skimage.measure import compare_ssim


def loss(pred, gt):
    t_valid = 0.01
    t_max = 10 # max range for 30MHz

    pred[pred >= t_max] = 0
    pred[pred <= 0] = 0

    pred_inv = 1.0 / (pred + 1e-8)
    gt_inv = 1.0 / (gt + 1e-8)

    # For numerical stability
    # mask1 = gt > t_valid
    # mask2 = gt < t_max
    # mask = mask1
    # for i in range(len(mask1)):
    #     for j in range(len(mask1[0])):
    #         if mask1[i][j] and mask2[i][j]:
    #             mask[i][j] = True
    #         else:
    #             mask[i][j] = False
    mask = (gt>t_valid) & (gt<t_max) & (pred>0)
    num_valid = mask.sum()
    if num_valid == 0:
        num_valid = 1
    # print(str(num_valid/217088*100)+"%")

    pred = pred[mask]
    gt = gt[mask]

    pred_inv = pred_inv[mask]
    gt_inv = gt_inv[mask]

    pred_inv[pred <= t_valid] = 0.0
    gt_inv[gt <= t_valid] = 0.0

    # RMSE / MAE
    diff = pred - gt
    diff_abs = np.abs(diff)
    diff_sqr = np.power(diff, 2)

    rmse = diff_sqr.sum() / num_valid
    rmse = np.sqrt(rmse)

    mae = diff_abs.sum() / num_valid

    # iRMSE / iMAE
    diff_inv = pred_inv - gt_inv
    diff_inv_abs = np.abs(diff_inv)
    diff_inv_sqr = np.power(diff_inv, 2)

    irmse = diff_inv_sqr.sum() / num_valid
    irmse = np.sqrt(irmse)

    imae = diff_inv_abs.sum() / num_valid

    # Rel
    rel = diff_abs / (gt + 1e-8)
    rel = rel.sum() / num_valid

    # delta
    r1 = gt / (pred + 1e-8)
    r2 = pred / (gt + 1e-8)
    ratio = np.maximum(r1, r2)

    del_1 = (ratio < 1.25).astype('float32')
    del_2 = (ratio < 1.25 ** 2).astype('float32')
    del_3 = (ratio < 1.25 ** 3).astype('float32')

    del_1 = del_1.sum() / num_valid
    del_2 = del_2.sum() / num_valid
    del_3 = del_3.sum() / num_valid

    result = [rmse, mae, irmse, imae, rel, del_1, del_2, del_3]
    # print(result)

    return result


def main(args):
    # args
    rows = 424
    cols = 512
    in_path = args.in_path      # result depth
    gt_path = args.gt_path      # ideal depth
    version = args.version
    out_path = args.save_dir    # save metric
    if not os.path.exists(out_path):
        os.makedirs(out_path)

    loss_rmse = []
    loss_mae = []
    loss_irmse = []
    loss_imae = []
    loss_rel = []
    loss_del_1 = []
    loss_del_2 = []
    loss_del_3 = []

    # nimg_list = sorted(os.listdir(in_path))
    nimg_list = []
    list_path = '/home/canyon/Documents/DepthCompletion/datasets/FLAT/list/test.txt'
    with open(list_path, 'r') as f:
        for line in f:
            path = line.strip('\n')
            nimg_list.append(path)

    ld = len(nimg_list)

    for imgidx in range(ld):
        # if imgidx % 100 == 0:
        #     print(imgidx)

        # get the inputs; data is a list of [inputs, labels]
        # num = num + 1

        if nimg_list[imgidx][0] == '.':     # avoid files automatically generated by OSX
            pass

        nimg_name = os.path.join(in_path, nimg_list[imgidx])
        with open(nimg_name, 'rb') as f:
            nimg = np.fromfile(f, dtype=np.float32).reshape(rows, cols) 
            nimg = np.nan_to_num(nimg, nan=0.0, posinf=0.0, neginf=0.0)

        rimg_name = os.path.join(gt_path, nimg_list[imgidx])  # use nimg_list to ensure same index
        with open(rimg_name, 'rb') as f:
            # rimg = cv2.imread(rimg_name, 0) # gray image
            # rimg = np.asarray(rimg)
            # rimg = rimg / 255 # [0,1]
            rimg = np.fromfile(f, dtype=np.float32).reshape(rows, cols)

        # total loss
        # convert mm to m
        rimg = 0.001 * rimg

        loss_list = loss(nimg, rimg)
        loss_rmse.append(loss_list[0])
        loss_mae.append(loss_list[1])
        loss_irmse.append(loss_list[2])
        loss_imae.append(loss_list[3])
        loss_rel.append(loss_list[4])
        loss_del_1.append(loss_list[5])
        loss_del_2.append(loss_list[6])
        loss_del_3.append(loss_list[7])
        # if (loss_list[0] <= 0.5):
        #     print(nimg_list[imgidx])

    # save
    rmse_mean = sum(loss_rmse) / len(loss_rmse)
    mae_mean = sum(loss_mae) / len(loss_mae)
    irmse_mean = sum(loss_irmse) / len(loss_irmse)
    imae_mean = sum(loss_imae) / len(loss_imae)
    rel_mean = sum(loss_rel) / len(loss_rel)
    del_1_mean = sum(loss_del_1) / len(loss_del_1)
    del_2_mean = sum(loss_del_2) / len(loss_del_2)
    del_3_mean = sum(loss_del_3) / len(loss_del_3)

    print("rmse_mean, mae_mean, irmse_mean, imae_mean: {0:.4f} {1:.4f} {2:.4f} {3:.4f}".format(rmse_mean, mae_mean,
                                                                                               irmse_mean, imae_mean))
    print("rel_mean, del_1_mean, del_2_mean, del_3_mean: {0:.4f} {1:.4f} {2:.4f} {3:.4f}".format(rel_mean, del_1_mean,
                                                                                                 del_2_mean,
                                                                                                 del_3_mean))

    with open(f"{out_path}/result_metrics_{version}.txt", "w") as text_file:
        text_file.write(
            "rmse_mean, mae_mean, irmse_mean, imae_mean: {0:.4f} {1:.4f} {2:.4f} {3:.4f} \n".format(rmse_mean, mae_mean,
                                                                                                    irmse_mean,
                                                                                                    imae_mean))
        text_file.write(
            "rel_mean, del_1_mean, del_2_mean, del_3_mean: {0:.4f} {1:.4f} {2:.4f} {3:.4f}".format(rel_mean, del_1_mean,
                                                                                                   del_2_mean,
                                                                                                   del_3_mean))


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-in", "--in_path", type=str, default='./predict_result2',
        help="pred depth directory")

    parser.add_argument(
        "-gt", "--gt_path", type=str, default='../FLAT/ideal_depth',
        help="ideal depth directory")
    
    parser.add_argument(
        "-out", "--save_dir", type=str, default='./result_metrics',
        help="result metrics directory")
    
    parser.add_argument(
        "-v", "--version", type=str,
        help="ideal depth directory")

    args = parser.parse_args()
    main(args)

